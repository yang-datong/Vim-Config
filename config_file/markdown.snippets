priority -50

#================== Function ==================
global !p
def create_table(snip):
    lists = snip.buffer[snip.line].strip()[3:].split("*",1)
    snip.buffer[snip.line] = ''
    rows = int(lists[0])
    columns = int(lists[1])
    head = ' | '.join(['$' + str(col) for col in range(1,columns+1)]) + "\n"
    delimiter = ':-|' * (columns-1) + ":-\n"
    body = ""
    for row in range(1,rows+1):
        body += ' | '.join(['$' + str(row*columns+col) for col in range(1,columns+1)]) + "\n"
    snip.expand_anon(head + delimiter + body)


def create_matrix_middle(snip,types=0):
    flag="mat"
    if(types == 0):
        types = "b"
    if(types == "v"):
        flag="vmat"
    rows = int(match.group(1))
    columns = int(match.group(2))
    old_str = snip.buffer[snip.line]
    snip.buffer[snip.line] = ''
    old_str = old_str.replace(flag+str(rows)+"*"+str(columns),"")
#make matrix
    body = ""
    anon_befor = "\\begin{"+types+"matrix} "
    for row in range(1,rows+1):
        body += ' & '.join(['$' + str(row*columns+col) for col in range(1,columns+1)]) + "\\\\\\\\"
    anon_end=" \end{"+types+"matrix}"
    snip.expand_anon(old_str + anon_befor + body + anon_end)

def create_matrix(snip,types=0):
    strLen = 3
    if(types == "b"):
        strLen = 4
    elif(types == "v"):
        strLen = 4
    else:
        types = "b"
    lists = snip.buffer[snip.line].strip()[strLen:].split("*",1)
    snip.buffer[snip.line] = ''
    rows = int(lists[0])
    columns = int(lists[1])
    anon_befor = "\\begin{"+types+"matrix}\n"
    body = ""
    for row in range(1,rows+1):
        body += ' & '.join(['$' + str(row*columns+col) for col in range(1,columns+1)]) + "\\\\\\\n"
    anon_end="\end{"+types+"matrix}"
    snip.expand_anon(anon_befor + body + anon_end)


def mermaid_auto_add_mark(snip):
    strs = snip.buffer[snip.line].split("-->")
    snip.buffer[snip.line] = ''
    body=""
    size=len(strs)
    for it in range(0,size):
        item = strs[it].replace("mark","").strip()
        body += str(it) +  "(\"" + item + "\")"
        if (it != size - 1):
            body += " --> "

    snip.expand_anon(body);
endglobal

#============== Latex =======================
snippet sum "sum" i
\sum $0
endsnippet

snippet 'ell(\d)' "ell" r
\ell_{`!p snip.rv = match.group(1)`} $0
endsnippet

snippet iff "iff"
\iff $0
endsnippet

snippet lam "lam" i
\lambda $0
endsnippet

snippet Vert "\Vert" i
\Vert ${1} \Vert ${0}
endsnippet

snippet vec "\vec" i
\vec{$1}$0
endsnippet

snippet int "\int"
\int_{$1}^\{$2\}$0
endsnippet

snippet del "\Delta{}" i
\Delta{$1}$0
endsnippet

snippet in "in"
\in$0
endsnippet

snippet pi "\pi" i
\pi$0
endsnippet

snippet ... "/dots" i
\dots $0
endsnippet

snippet '(g|l)eq' "\geq" ir
\\`!p snip.rv = match.group(1)`eq $0
endsnippet

snippet log "\log" i
\log{$1}$0
endsnippet

snippet cdot "\cdot" i
\cdot $1
endsnippet

snippet 'ln(x{0,1})' "\lnx" ir
\ln{`!p snip.rv = match.group(1)`}$0
endsnippet

snippet br "<br>"
<br>
endsnippet

snippet be "\beta"
\beta $0
endsnippet

snippet al "\alpha"
\alpha $0
endsnippet

snippet neq "\neq" i
\neq $0
endsnippet

snippet inf "\infty" it
\infty $0
endsnippet

snippet -> "\right" i
\rightarrow $0
endsnippet

snippet <- "\left" i
\leftarrow $0
endsnippet

snippet lim "lim" i
\lim{$1} $0
endsnippet

snippet lims "lims" i
\lim\limits_{${1:x} \rightarrow ${2:\infty}}
endsnippet

snippet cases "cases" i
\begin{cases} &${1} \\\ &${2} \\\ \end{cases}
endsnippet

snippet clear "clear"
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
endsnippet
#---------------------------------------

snippet mkkb "display math aligned"
$$
\begin{aligned}
& ${1} \\\
& ${2} \\\
& ${3} \\\
& ${4} \\\
& ${5} \\\
\end{aligned}
$$
endsnippet

snippet mkk "display math"
$$
$0
$$
endsnippet

snippet beg "begin{} / end{}" i
\begin{$1}
$0
\end{$1}
endsnippet

snippet qu "quad" i
\\quad ${0}
endsnippet

snippet bec "because" i
\because ${0}
endsnippet

snippet so "therefore" i
\therefore ${0}
endsnippet

snippet box "Box"
<div style=border-style:solid;border-color:red;text-align:center;padding:10px;border-width:2px>
${1:This is a Box}
</div>
endsnippet

snippet mk "Math" i
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
    snip.rv = ' '
else:
    snip.rv = ''
`${2}
endsnippet

snippet dm "Math"
\[
$1
.\] $0
endsnippet

snippet sr "^2" iA
^2
endsnippet

snippet cb "^3" iA
^3
endsnippet

snippet compl "complement" iA
^{c}
endsnippet

snippet td "superscript" iA
^{$1}$0
endsnippet

snippet sq "\sqrt" i
\\sqrt{$1}$0
endsnippet

snippet phi "\phi" i
\\phi $0
endsnippet

snippet //c "text-bold" iA
<font color="red"> ${VISUAL} </font>$0
endsnippet

snippet //( "()visual" iA
(${VISUAL})$0
endsnippet

#\textcolor{red/blue/green/black/white/cyan/magenta/yellow}{text}
snippet //red "color_red" iA
\textcolor{red}{${VISUAL}}
endsnippet

snippet //white "color_white" iA
\textcolor{white}{(${VISUAL})}
endsnippet

snippet //v "frac_visual" iA
\\frac{${VISUAL}}{${1}}$0
endsnippet

snippet // "Fraction" i
\\frac{$1}{$2}$0
endsnippet

priority 1000
snippet '^.*\)/' "() Fraction" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
    if stripped[i] == ')': depth += 1
    if stripped[i] == '(': depth -= 1
    if depth == 0: break;
    i -= 1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet


#================== 正则 ==================
snippet '(sin|cos|tan)x' "sin{}" ir
\\`!p snip.rv = match.group(1)`{${1}}$0
endsnippet

snippet '(sin|cos|tan)x' "sin{x}" ir
\\`!p snip.rv = match.group(1)`{x}$0
endsnippet

snippet '([Ffg])'{0,1}xi' "f(\xi)" ir
`!p snip.rv = match.group(1)`(\xi)$0
endsnippet

snippet '([Ffg])('{0,3})((?!t)[a-su-z0-9])' "f(x)" ir
`!p snip.rv = match.group(1)``!p snip.rv = match.group(2)`(`!p snip.rv = match.group(3)`)
endsnippet

snippet '(x|y)n' "xyg_n" ir
`!p snip.rv = match.group(1)`_n
endsnippet

snippet 'phi((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)' "\phi(x)" ir
\\phi(`!p snip.rv = match.group(1)`)
endsnippet

#old snippet '\D((?!t|f)[A-Za-z])(\d)' "auto subscript" r
snippet '((?!t|f)[A-Za-z])(\d)' "auto subscript" r
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet

snippet '((?!t|f)[A-Za-z])(\d)(\d)' "auto subscript2" r
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)``!p snip.rv = match.group(3)`}
endsnippet

snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet


#================== Markdown ==================
#*${1:${VISUAL}}*$0
snippet * "italics"
\\cdot $0
endsnippet

snippet ** "bold" iA
**${1:${VISUAL}}**$0
endsnippet

snippet ` "bold" iA
\`${1:${VISUAL}}\`$0
endsnippet

snippet *** "bold italics" iA
***${1:${VISUAL}}***$0
endsnippet


snippet link "Link to something" i
[${2:text}](${1:${VISUAL:url}})$0
endsnippet

snippet img "Images" i
<img src="$1" alt="$1" width=70% />
endsnippet

snippet ilc "Inline Code" i
\`$1\`$0
endsnippet

snippet sec "Section" b
# ${1:Section Name} #
$0
endsnippet

snippet ssec "Sub Section" b
## ${1:Section Name} ##
$0
endsnippet

snippet sssec "SubSub Section" b
### ${1:Section Name} ###
$0
endsnippet

snippet par "Paragraph" b
#### ${1:Paragraph Name} ####
$0
endsnippet

snippet spar "Paragraph" b
##### ${1:Paragraph Name} #####
$0
endsnippet

snippet mermaid "mermaid"
\`\`\`mermaid
%%{init: {'theme': 'base','themeVariables': {'primaryBorderColor':'#fff','primaryTextColor': '#fff', 'primaryColor': '#383838'}}}%%
graph LR
%%--------------------------------------------------------------------
${1} --> ${2}

%%--------------------------------------------------------------------
\`\`\`
endsnippet

snippet code "Codeblock" b
\`\`\`${1:bash}
$2
\`\`\`
$0
endsnippet

snippet ref "ref"
[ ${1:Label} ]:${2:https://www.bilibili.com}
endsnippet

#snippet ref "Reference Link"
#[${1:${VISUAL:Text}}][${2:id}]$0
#
#[$2]:${4:http://${3:www.url.com}} "${5:$4}"
#endsnippet

snippet fnt "Footnote"
[^${1:${VISUAL:Footnote}}]$0

[^$1]:${2:Text}
endsnippet

#================== Function ==================
pre_expand "create_table(snip)"
snippet "tab(\d+\*\d+)" "Customizable table" br
endsnippet

pre_expand "create_matrix(snip)"
snippet '^mat(\d+\*\d+)' "matrix" r
endsnippet

pre_expand "create_matrix(snip,\"v\")"
snippet '^vmat(\d+\*\d+)' "matrix" r
endsnippet

pre_expand "create_matrix_middle(snip)"
snippet '.*\smat(\d)\*(\d)' "matrix_middle" r
endsnippet

pre_expand "create_matrix_middle(snip,\"v\")"
snippet '.*\svmat(\d)\*(\d)' "matrix_middle" r
endsnippet

pre_expand "mermaid_auto_add_mark(snip)"
snippet mark "auto add mark" "re.match('.*\s-->\s.*', snip.buffer[snip.line])" e
endsnippet

snippet tab_html "tab_html"
<table>
<!- head ->
  <tr>
    <th>month</th><th>time</th><th>work</th>
  </tr>
  <tr>
   <td rowspan="3">6月</td><td>语文</td><td>95</td>
  </tr>
  <tr>
   <td>数学</td><td>96</td>
  </tr>
  <tr>
   <td>英语</td><td>92</td>
  </tr>
</table>
endsnippet

#b 表示触发字符应该在一行的开始
#i 表示触发字符可以在单词内（连续展示会使用这个选项）
#w 表示触发字符的前后必须是一个字母分界点
#r 表示触发字符可以是一个正则表达式
#t 表示展开的代码片段中如果有制表符，原样输出，即使你的 vimrc 里面设置了 expandtab
#m 表示删除代码片段右边的所有空白字符
#e 表示自定义上下文
#A 表示自动触发，不需要按 tab，类似于 VIM 中的 abb
#https://github.com/SirVer/ultisnips/tree/master/doc
